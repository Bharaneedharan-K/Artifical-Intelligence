exp - 1

      Develop a MATLAB program to synthesize a square wave using Fourier series, applicable in 
      creating custom sounds and analyzing audio signals.

      1. Initialize parameters including fundamental frequency, sampling frequency, duration, and the
      number of harmonics.
      2. Generate a time vector from 0 to the specified duration with an appropriate step size.
      3. Compute the Fourier series approximation by summing the odd harmonics of the sine function.
      4. Normalize the synthesized wave to ensure it stays within the desired amplitude range.
      5. Plot and visualize the generated square wave along with its frequency spectrum.
      6. Play the synthesized wave using MATLAB’s sound() function to hear the output.


exp -2 


     Develop MATLAB program to analyze ECG signals using Fourier and Z-Transforms, helping to identify 
     heart rate variability (HRV).

      1. Load the ECG signal from a dataset or an acquisition device for analysis.
      2. Preprocess the signal by applying filtering techniques to remove noise and artifacts.
      3. Compute the Fast Fourier Transform (FFT) to analyze the frequency components of the ECG signal.
      4. Compute the Z-Transform to study the pole-zero characteristics and system behavior of the signal.
      5. Identify heart rate variability (HRV) by detecting R-peaks and analyzing time and frequency 
      domain features.
      6. Visualize the results by plotting the ECG waveform, FFT spectrum, and HRV analysis for 
      interpretation.


exp - 3

     Develop a MATLAB program to generate and visualize common continuous-time and discrete-time signals 
     (step, impulse, exponential, ramp, sine), analyzing and comparing their properties in both domains 
     to model and understand the behavior of a first-order RC circuit's response to various inputs.

      1. Define continuous-time and discrete-time variables over a specified range for signal generation.
      2. Generate common signals, including step, impulse, exponential, ramp, and sine waves, in both 
      continuous and discrete domains.
      3. Analyze and compare the properties of these signals by examining their amplitude, frequency, and 
      time-domain characteristics.
      4. Model the behavior of a first-order RC circuit by defining its parameters and mathematical response 
      to different input signals.
      5. Compute the circuit’s response using convolution or differential equation methods to understand 
      system dynamics.
      6. Visualize and compare the generated signals and the RC circuit’s response by plotting results in 
      both continuous and discrete domains.


exp - 4

      Develop a MATLAB program to analyze the frequency response of a digital filter, visualizing its magnitude
      and phase characteristics to evaluate its performance and key parameters. 

      1. Define the digital filter specifications, including filter type, order, cutoff frequency, and 
      sampling rate.
      2. Design the filter using standard MATLAB functions such as butter, cheby1, or fir1 based on the 
      required response.
      3. Compute the frequency response of the filter using the freqz function to obtain magnitude and phase 
      information.
      4. Analyze the magnitude response to evaluate filter attenuation, passband, and stopband behavior.
      5. Examine the phase response to assess phase distortion and filter stability.
      6. Visualize the magnitude and phase characteristics using plots to interpret the filter’s performance 
      effectively.

exp - 5

	Develop a MATLAB program to compute and visualize the Fourier and Z-transforms of a sampled audio 
	signal, analyzing its frequency content and relating the pole-zero plot of the Z-transform to
	the presence of specific frequencies and the overall stability of the digital representation.

	1. Read the audio signal using audioread, convert it to mono if it's stereo, and normalize it.
	2. Compute the FFT to get the frequency content and plot its magnitude spectrum.
	3. Model the signal or system for Z-transform analysis using zplane or related functions.
	4. Visualize both FFT and Z-transform, showing frequency peaks and the pole-zero plot.
	5. Interpret the plots to identify key frequencies and check if the poles lie inside the unit circle for 
	   stability.

         %% 
            % MATLAB Program to compute and visualize Fourier and Z-transforms of a sampled audio signal
            clear;
            clc;
            % Step 1: Load the audio file (Use your own audio file path here)
            [audio_signal, fs] = audioread('exp5.wav'); % Load the audio signal (e.g., .wav file)
            audio_signal = audio_signal(:,1); % Use only one channel if stereo (you can also analyze stereo if needed)
            % Step 2: Compute and visualize the Fourier Transform (Frequency content)
            N = length(audio_signal);        % Length of the audio signal
            t = (0:N-1) / fs;                % Time vector for the signal
            f = fs * (0:(N/2)) / N;          % Frequency vector for positive frequencies
            % Compute the Fourier Transform (FFT)
            audio_fft = fft(audio_signal);
            % Compute the magnitude and phase of the FFT
            audio_fft_mag = abs(audio_fft) / N;
            audio_fft_mag = audio_fft_mag(1:N/2+1);  % Only plot the positive frequencies
            audio_fft_phase = angle(audio_fft(1:N/2+1));
            % Plot the Fourier Transform (Magnitude and Phase)
            figure;
            subplot(2,1,1);
            plot(f, 20*log10(audio_fft_mag));   % Magnitude in dB
            title('Magnitude Spectrum (Fourier Transform)');
            xlabel('Frequency (Hz)');
            ylabel('Magnitude (dB)');
            grid on;
            subplot(2,1,2);
            plot(f, audio_fft_phase);           % Phase spectrum
            title('Phase Spectrum (Fourier Transform)');
            xlabel('Frequency (Hz)');
            ylabel('Phase (radians)');
            grid on;
            % Step 3: Compute and visualize the Z-Transform
            % Use the Discrete-Time Fourier Transform (DTFT) approximation for Z-transform
            z = exp(1j * 2 * pi * (0:N-1) / N);  % The Z-transform variable (on the unit circle)
            z_transform = fft(audio_signal);  % Use FFT as an approximation of the Z-transform
            % Plot the pole-zero plot of the Z-transform
            figure;
            zplane(z_transform, ones(N,1));  % Plot the pole-zero plot (unit circle)
            title('Pole-Zero Plot of the Z-Transform');
            % Step 4: Analyze the relationship of the pole-zero plot to frequency and stability
            % Comment on the relationship between the poles and zeros and the frequency content
            disp('Z-Transform Analysis:');
            disp('Poles are the points inside the unit circle and zeros are on the unit circle.');
            disp('Stable systems have poles inside the unit circle.');
            disp('The frequencies with significant energy in the signal will correlate with zeros on the unit circle.');
            disp('The stability of the system is related to the position of the poles in the Z-plane.');
            % Step 5: Optional - Listen to the audio signal
            % sound(audio_signal, fs); % Uncomment to play the audio signal

exp - 6

	Develop a MATLAB program to compute and visualize the cross-correlation of two given sequences x(n) and y(n),
	and the autocorrelation of sequence x(n), demonstrating their properties and potential use in signal analysis 
	applications like echo detection or signal alignment.

	1. Define or input the sequences x(n) and y(n) manually or through a signal source.
	2. Compute the cross-correlation between x(n) and y(n) using MATLAB’s xcorr function.
	3. Compute the autocorrelation of x(n) by correlating it with itself using xcorr(x).
	4. Plot the results of both cross-correlation and autocorrelation to observe symmetry and peak alignment.
	5. Interpret the plots to understand time shift, similarity, or delays—useful in applications like echo detection 
	   or signal synchronization.

         clc;
            clear;
            close all;

            % --- Define signals x(n) and y(n) ---
            x = [1 2 3 4 3 2 1];                % Original signal
            y = [0 0 1 2 3 4 3 2 1 0 0];       % Delayed version of x (echo)

            n_x = 0:length(x)-1;               % Time index for x(n)
            n_y = 0:length(y)-1;               % Time index for y(n)

            % --- Cross-Correlation between x and y ---
            [crossCorr, lagsCross] = xcorr(y, x);  

            % --- Autocorrelation of x ---
            [autoCorr, lagsAuto] = xcorr(x);       

            % --- Plotting ---

            figure;

            % Plot 1: Original Sequence x(n)
            subplot(3,2,1);
            stem(n_x, x, 'filled');
            title('Original Sequence x(n)');
            xlabel('n');
            ylabel('Amplitude');
            grid on;

            % Plot 2: Second Sequence y(n)
            subplot(3,2,2);
            stem(n_y, y, 'filled');
            title('Modified Sequence y(n)');
            xlabel('n');
            ylabel('Amplitude');
            grid on;

            % Plot 3: Cross-Correlation
            subplot(3,2,[3 4]);
            stem(lagsCross, crossCorr, 'filled');
            title('Cross-Correlation between y(n) and x(n)');
            xlabel('Lag');
            ylabel('Amplitude');
            grid on;

            % Plot 4: Autocorrelation
            subplot(3,2,[5 6]);
            stem(lagsAuto, autoCorr, 'filled');
            title('Autocorrelation of x(n)');
            xlabel('Lag');
            ylabel('Amplitude');
            grid on;

            % --- Notes ---
            disp('--- Signal Analysis Applications ---');
            disp('1. Echo Detection: The peak in cross-correlation indicates the echo delay.');
            disp('2. Signal Alignment: Cross-correlation helps align two similar signals.');
            disp('3. Feature Detection: Autocorrelation identifies repeating patterns in signals.');

exp - 7

	Develop a MATLAB program to implement and visualize linear convolution of discrete-time sequences, simulating
	a digital filter's effect on an input signal for applications in areas like audio or image processing.
	
	1. Input the discrete-time sequences representing the signal and filter impulse response.
	2. Use the conv function to perform linear convolution of the two sequences.
	3. Calculate the time axis for the output based on the lengths of the input signals.
	4. Plot the original sequences and the output to visualize the filtering effect.
	5. Interpret the result to understand how the filter modifies the input for applications like audio or image 
	   processing

         clc;
            clear;
            close all;

            %% --- Define Input Signal (x[n]) and Filter (h[n]) ---
            % Example: x[n] = input audio pulse; h[n] = filter (e.g., moving average)

            x = [1 2 3 4 3 2 1];               % Input signal
            h = [0.2 0.2 0.2 0.2 0.2];         % Simple averaging filter (FIR filter)

            n_x = 0:length(x)-1;               % Time index for x[n]
            n_h = 0:length(h)-1;               % Time index for h[n]

            %% --- Perform Linear Convolution ---
            y = conv(x, h);                    % Output signal after filtering
            n_y = 0:length(y)-1;               % Time index for y[n]

            %% --- Plotting ---
            figure;

            % Plot 1: Input Signal x[n]
            subplot(3,1,1);
            stem(n_x, x, 'filled');
            title('Input Signal x[n]');
            xlabel('n');
            ylabel('Amplitude');
            grid on;

            % Plot 2: Filter h[n]
            subplot(3,1,2);
            stem(n_h, h, 'filled');
            title('Filter Impulse Response h[n]');
            xlabel('n');
            ylabel('Amplitude');
            grid on;

            % Plot 3: Output Signal y[n] = x[n] * h[n]
            subplot(3,1,3);
            stem(n_y, y, 'filled');
            title('Output Signal y[n] = x[n] * h[n] (Linear Convolution)');
            xlabel('n');
            ylabel('Amplitude');
            grid on;

            %% --- Application Notes ---
            disp('--- Linear Convolution & Digital Filtering ---');
            disp('1. Convolution simulates how an input signal is modified by a filter.');
            disp('2. Used in audio processing for effects like echo, reverb, noise reduction.');
            disp('3. Used in image processing for blurring, sharpening, edge detection.');


